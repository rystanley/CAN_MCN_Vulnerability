##load libraries
library(sf)
library(dplyr)
library(raster)
library(ggplot2)
library(tidyr)
library(rnaturalearth)
library(patchwork)
library(stars)
library(rasterize)
library(fasterize)

sf_use_s2(FALSE) #makes some of the sf functions run a bit less buggy

#Projections ------------
latlong <- "+proj=longlat +datum=NAD83 +no_defs +ellps=GRS80 +towgs84=0,0,0"
CanProj <- "+proj=lcc +lat_1=49 +lat_2=77 +lat_0=63.390675 +lon_0=-91.86666666666666 +x_0=6200000 +y_0=3000000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"

#load polygons ----- 
#using the polygon_load function - this load polygons for each function instead of re-writing the code multiple times. Makes things more consistent. 
source("code/polygon_load.R")
polygon_load()

#load the datasets to be rasterized ------
rcp_26 <- read.csv("data/climate_vulnerability_26.csv")
rcp_85 <- read.csv("data/climate_vulnerability_85.csv")
bathy <- read.csv("data/bathy.csv")%>%
        mutate(bathy = ifelse(bathy>0,NA,bathy))

#set limits for the raster based on the limits of the two datasets
lat_lim <- c(min(c(rcp_26$lat,bathy$lat)),max(c(rcp_26$lat,bathy$lat)))
lon_lim <- c(min(c(rcp_26$lon,bathy$lon)),max(c(rcp_26$lon,bathy$lon)))

#create an empty raster to be used in the rasterize process for a 0.25 degree raster
ras_dummy <-expand.grid(lon=seq(lon_lim[1],lon_lim[2],0.25),
                        lat=seq(lat_lim[1],lat_lim[2],0.25))%>%
            rasterFromXYZ(.,crs = latlong)

#now create a raster brick for the different values for each variable ------
raster_names <- names(rcp_26)[4:length(rcp_26)]

  #RCP 2.6
  rcp_26_stack <- list()
  for (i in raster_names){
    rcp_26_stack[[i]] <- rasterize(x=rcp_26[,c("lon","lat")], # lon-lat data
                                    y=ras_dummy, # raster object
                                    field=rcp_26[,i], # vals to fill raster with
                                    fun=mean)
    
  }
  
  #RCP 8.5
  rcp_85_stack <- list()
  for (i in raster_names){
    rcp_85_stack[[i]] <- rasterize(x=rcp_85[,c("lon","lat")], # lon-lat data
                                   y=ras_dummy, # raster object
                                   field=rcp_85[,i], # vals to fill raster with
                                   fun=mean)
    
  }

  #Add in the bathymetry to each raster stack (one for each RCP)
  rcp_26_stack[["bathy"]] <- rasterize(x=bathy[,c("lon","lat")], # lon-lat data
                                       y=ras_dummy, # raster object
                                       field=bathy[,"bathy"], # vals to fill raster with
                                       fun=mean)
                              
  
  rcp_85_stack[["bathy"]] <- rasterize(x=bathy[,c("lon","lat")], # lon-lat data
                                       y=ras_dummy, # raster object
                                       field=bathy[,"bathy"], # vals to fill raster with
                                       fun=mean)

#convert to raster bricks -----------
rcp_26_brick <- rcp_26_stack%>%brick()
rcp_85_brick <- rcp_85_stack%>%brick()

#Create raster masks for the hierarchical extractions ----------

  # #raster 'mask' for the bioregions
  bioregion_extent <- extent(can_bioregions%>%st_transform(latlong))
  bioregion_raster_mask <- rasterize(can_bioregions%>%st_transform(latlong)%>%as_Spatial(),crop(rcp_26_stack[[1]],bioregion_extent,snap="out"),getCover=TRUE)
  bioregion_raster_mask[bioregion_raster_mask == 0] <- NA
  
  # #raster 'mask' for the Canadain MPA network
  network_extent <- extent(can_mcn%>%st_transform(latlong))
  network_raster_mask <- rasterize(can_mcn%>%st_transform(latlong)%>%as_Spatial(),crop(rcp_26_stack[[1]],network_extent,snap="out"),getCover=TRUE)
  network_raster_mask[network_raster_mask == 0] <- NA
   
  # #raster 'mask' for the Scotian Shelf-Bay of Fundy Bioregion
  network_extent_mar <- extent(mar_network%>%st_transform(latlong))
  network_raster_mask_mar <- rasterize(mar_network%>%st_transform(latlong)%>%as_Spatial(),crop(rcp_26_stack[[1]],network_extent_mar,snap="out"),getCover=TRUE)
  network_raster_mask_mar[network_raster_mask_mar == 0] <- NA
  
  #save the rasters so you don't have to re-create them each time
    #save(bioregion_raster_mask,network_raster_mask,network_raster_mask_mar,file="output/network_raster_masks.RData")
  
  #load the raster masks (if they are already created and you don't want to re-create)
    #load("output/network_raster_masks.RData")

#BIOREGIONAL extractions --------
    
    #** this can take a while 
    bioregion_extract_26 <- rcp_26_stack%>%
                         brick()%>%#convert to raster 'brick'
                         crop(.,bioregion_extent)%>%
                         raster::mask(bioregion_raster_mask)%>%
                         st_as_stars()%>% #convert to stars raster brick
                         st_as_sf()%>% #convert to sf dataframe
                         st_transform(4326)%>%
                         st_intersection(.,can_bioregions%>%st_transform(4326)%>%st_make_valid())%>%
                         st_transform(latlong)%>% #transform back to the raster projection
                         mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                 id = 1:n(),rcp=2.6)

    bioregion_extract_85 <- rcp_85_stack%>%
                            brick()%>%#convert to raster 'brick'
                            crop(.,bioregion_extent)%>%
                            raster::mask(bioregion_raster_mask)%>%
                            st_as_stars()%>% #convert to stars raster brick
                            st_as_sf()%>% #convert to sf dataframe
                            st_transform(4326)%>%
                            st_intersection(.,can_bioregions%>%st_transform(4326)%>%st_make_valid())%>%
                            st_transform(latlong)%>% #transform back to the raster projection
                            mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                   id = 1:n(),rcp=8.5)

    #bind it together
    bioregion_extract <- rbind(bioregion_extract_26,bioregion_extract_85)
    
    #save the outputs
    #save(bioregion_extract,file="output/bioregion_extract.RData") # this takes a while to sync with github so only do this if you need to and something has changed. 
 

#Canadian Marine Conservation Network (MCN) extractions  ----------------
    
    #do the extractions for the bioregions that contain each conservation closure but exclude the area that is in the closure (this is akin to Dan's thoughts re: analysis later)
    can_network_combo <- can_mcn%>%
                          st_transform(CanProj)%>%
                          st_buffer(2)%>%
                          st_combine()%>%
                          st_make_valid()%>%
                          st_transform(4326)
    
    region_invert_extracts <- NULL
    
    for(i in unique(can_bioregions$region)){
      
      message(paste0("Working on ",i," bioregion"))
      
      temp_sites <- can_mcn_regions%>%filter(region==i)%>%pull(NAME_E) #sites in the focal region (i)
      
      region_network_temp <- can_mcn%>%
        filter(NAME_E %in% temp_sites)%>%
        st_transform(CanProj)%>%
        st_buffer(2)%>%
        st_combine()%>%
        st_make_valid()%>%
        st_transform(4326)
      
      #the arctic Basin region has some overlap issues whereby the only MPA is not contained fully within the bioregion we need to combine them to make this work 
            # ggplot()+
            #   geom_sf(data=can_mcn%>%filter(NAME_E == "Tuvaijuittuq Marine Protected Area"),fill="red")+
            #   geom_sf(data=can_bioregions%>%filter(region=="Arctic Basin"))
      
      if(i == "Arctic Basin"){
        
        region_temp <- can_bioregions%>%
          filter(region == i)%>%
          dplyr::select(geometry)%>%
          rbind(.,can_mcn%>%filter(NAME_E == "Tuvaijuittuq Marine Protected Area")%>%dplyr::select(geometry))%>%
          st_combine()%>%
          st_make_valid()%>%
          st_buffer(0.5)%>%
          st_transform(4326)%>%
          st_difference(.,region_network_temp%>%st_make_valid())%>% #get the invert of the region
          st_transform(latlong)%>%
          st_as_sf()%>%
          mutate(ocean="Arctic",region="Arctic Basin")
        
      }
     
      if(i != "Arctic Basin" ){
      region_temp <- can_bioregions%>%
                     filter(region == i)%>%
                     st_make_valid()%>%
                     st_transform(4326)%>%
                     st_difference(.,region_network_temp%>%st_make_valid())%>% #get the invert of the region
                     st_transform(latlong)
      }
      
      
      region_temp_mask <- region_temp%>%
                          as_Spatial()%>%
                          rasterize(.,crop(rcp_26_stack[[1]],extent(can_bioregions%>%filter(region == i)%>%st_transform(latlong)),snap="out"),getCover=TRUE)
      
      region_temp_mask[region_temp_mask == 0] <- NA
      
      region_temp_extract_26 <- rcp_26_stack%>%
                                brick()%>%#convert to raster 'brick'
                                crop(.,region_temp_mask%>%extent())%>%
                                raster::mask(region_temp_mask)%>%
                                st_as_stars()%>% #convert to stars raster brick
                                st_as_sf()%>% #convert to sf dataframe
                                st_transform(4326)%>%
                                st_intersection(.,region_temp%>%st_transform(4326))%>%
                                st_transform(latlong)%>% #transform back to the raster projection
                                mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                       id = 1:n(),rcp=2.6,location="outside")
      
      region_temp_extract_85 <- rcp_85_stack%>%
                                brick()%>%#convert to raster 'brick'
                                crop(.,region_temp_mask%>%extent())%>%
                                raster::mask(region_temp_mask)%>%
                                st_as_stars()%>% #convert to stars raster brick
                                st_as_sf()%>% #convert to sf dataframe
                                st_transform(4326)%>%
                                st_intersection(.,region_temp%>%st_transform(4326))%>%
                                st_transform(latlong)%>% #transform back to the raster projection
                                mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                       id = 1:n(),rcp=8.5,location="outside")
      
      #rbind the outputs into one big dataframe. This is the slowest way to do it but hopefully it is intuitive. 
      region_invert_extracts <- rbind(region_invert_extracts,region_temp_extract_26,region_temp_extract_85)
    }
    
    #extract the networks inside conservation areas within each region
    can_network_inside_26 <- rcp_26_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask%>%extent())%>%
                              raster::mask(network_raster_mask)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,can_mcn%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=2.6,location="inside")

    can_network_inside_85 <- rcp_85_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask%>%extent())%>%
                              raster::mask(network_raster_mask)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,can_mcn%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=8.5,location="inside")

    
    #now combine it all together
    can_network_extract <- rbind(can_network_inside_26,can_network_inside_85)%>%
                           left_join(.,can_mcn_regions%>%dplyr::select(-c(lat,long)))
    
    can_mcn_extracts <- rbind(can_network_extract,
                              region_invert_extracts%>%
                                mutate(type=NA,NAME_E=NA)%>%
                                dplyr::select(names(can_network_extract)))

    #save the outputs
    #save(can_mcn_extracts,file="output/can_network_extract.RData")  # this takes a while to sync with github so only do this if you need to and something has changed. 

#Scotian Shelf-Bay of Fundy Draft Network extractions -------------
    
    #make a single polygon for the network
    mar_network_combo <- mar_network%>%
                         st_transform(CanProj)%>%
                         st_buffer(2)%>%
                         st_combine()%>%
                         st_make_valid()%>%
                         st_transform(4326)

    #carve out the difference between the region and the network (holes where MPAs are)
    mar_network_invert <- mar_region%>%
                          st_transform(4326)%>%
                          st_difference(.,mar_network_combo)%>%
                          st_transform(latlong)

    mar_network_invert_mask <- mar_network_invert%>%
                                as_Spatial()%>%
                                rasterize(.,crop(rcp_26_stack[[1]],extent(mar_region%>%st_transform(latlong)),snap="out"),getCover=TRUE)

    mar_network_invert_mask[mar_network_invert_mask == 0] <- NA

    #now extract for the 'inside' and 'outside' of the MAR network
    mar_network_outside_26 <- rcp_26_stack%>%
                             brick()%>%#convert to raster 'brick'
                             crop(.,mar_network_invert_mask%>%extent())%>%
                             raster::mask(mar_network_invert_mask)%>%
                             st_as_stars()%>% #convert to stars raster brick
                             st_as_sf()%>% #convert to sf dataframe
                             st_transform(4326)%>%
                             st_intersection(.,mar_network_invert)%>%
                             st_transform(latlong)%>% #transform back to the raster projection
                             mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                       id = 1:n(),rcp=2.6,location="outside")

    mar_network_outside_85 <- rcp_85_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,mar_network_invert_mask%>%extent())%>%
                              raster::mask(mar_network_invert_mask)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,mar_network_invert)%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=8.5,location="outside")

    mar_network_inside_26 <- rcp_26_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask_mar%>%extent())%>%
                              raster::mask(network_raster_mask_mar)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,mar_network%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=2.6,location="inside")

    mar_network_inside_85 <- rcp_85_stack%>%
                              brick()%>%#convert to raster 'brick'
                              crop(.,network_raster_mask_mar%>%extent())%>%
                              raster::mask(network_raster_mask_mar)%>%
                              st_as_stars()%>% #convert to stars raster brick
                              st_as_sf()%>% #convert to sf dataframe
                              st_transform(4326)%>%
                              st_intersection(.,mar_network%>%st_transform(4326))%>%
                              st_transform(latlong)%>% #transform back to the raster projection
                              mutate(cell_area=as.vector(st_area(.)/1000/1000),
                                     id = 1:n(),rcp=8.5,location="inside")

    #combine the data together
    mar_network_extract <- rbind(mar_network_inside_26,mar_network_outside_26%>%rename(mar_name=mar_region)%>%mutate(mar_type="region")%>%dplyr::select(names(mar_network_inside_26)),
                                 mar_network_inside_85,mar_network_outside_85%>%rename(mar_name=mar_region)%>%mutate(mar_type="region")%>%dplyr::select(names(mar_network_inside_85)))
    
    #save the output to reduce computational time
    #save(mar_network_extract,file="output/mar_network_extract.RData") # this takes a while to sync with github so only do this if you need to and something has changed. 
    
    #to viz how this has worked 
    ggplot()+geom_sf(data=mar_network_extract,aes(fill=location))
    
